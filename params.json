{"name":"Booleansearchengine","tagline":"BooleanSearchEngine","body":"### Building a Boolean Search Engine\r\nimplement the methods AND, OR, NOT and perform some queries. We have a small corpus (document collection)\r\nof Amazon.com reviews on electronics. After your page is generated, you can check out the new branch:\r\n\r\n```\r\n$ cd krithivasanchandran/BooleanSearchEngine\r\n$ git fetch origin\r\n$ git checkout BooleanSearchEngine\r\n```\r\n\r\n\r\n### Corpus (document collection): mini_proj/all.txt\r\nThis contains the raw reviews. Each line is a review/document in our context. There are total 1248 documents. Documents in theposting list should be indexed from 1 (and not 0) where the first document refers to the first line in mini_proj/all.txt.\r\nThe corpus is also available in document matrix format: mini_proj/docs.txt with associated vocabulary mapping\r\nmini_proj/vocab_map.txt generated using a helper method DatasetFormatter.\r\n\r\n### Pre-processing: DatasetFormatter.java\r\nThis class provides preprocessing (parsing, generating the vocabulary map, filtering stopwords based on counts, etc.) already implemented to get you started. You are required to work on the formatted data produced by this class. Your best bet is to use it directly within the constructor of BooleanRetrieval.java class as follows:\r\n\r\n```\r\npublic BooleanRetrieval() throws Exception{\r\n// Initialize variables and Format the data using a pre-processing class and\r\nset up variables\r\ninvIndex = new HashMap<String, Set<Integer>>();\r\nDatasetFormatter formater = new DatasetFormatter();\r\nformater.textCorpusFormatter(\"./all.txt\");\r\ndocs = formater.getDocs();\r\nvocab = formater.getVocab();\r\n```\r\n\r\n###void createPostingList()\r\nYou are required to build the inverted index in the method void createPostingList() for this preprocessed corpus. Note\r\nthat you are required to work with the pre-processed data, i.e., output of\r\nDatasetFormatter.textCorpusFormatter()defined in Section 2 OR the document matrix/vocabulary defined by the\r\nfiles mini_proj/docs.txt and mini_proj/vocab_map.txt (which are the same). Do NOT work with the raw corpus mini_proj/all.txt\r\nand re-parse!\r\n\r\n```\r\nvoid createPostingList() {\r\n//Initialze the inverted index with a SortedSet (so that the later additions become\r\neasy!)\r\nfor(String s:vocab){\r\ninvIndex.put(s, new TreeSet<Integer>());\r\n}\r\n//for each doc\r\nfor(int i=0; i<docs.length; i++){\r\n//for each word of that doc\r\nfor(int j=0; j<docs[i].length; j++){\r\n//Get the actual word in position j of doc i\r\nString w = map.get(docs[i][j]);\r\n//Now simply update the posting list of this word w in the invIndex\r\nby adding the document i\r\n```\r\n\r\n### Set<Integer> intersection(Set<Integer> a, Set<Integer> b)\r\nThis method accepts two posting lists using the Set collections and returns the intersection of them. You are required to implement it using the algorithm for intersection discussed in class.\r\n\r\n```\r\nSet<Integer> intersection(Set<Integer> a, Set<Integer> b){\r\n/*\r\nFirst convert the posting lists from sorted set to something we\r\ncan iterate easily using an index. I choose to use ArrayList<Integer>.\r\nOnce can also use other enumerable.\r\n*/\r\nArrayList<Integer> PostingList_a = new ArrayList<Integer>(a);\r\nArrayList<Integer> PostingList_b = new ArrayList<Integer>(b);\r\nTreeSet result = new TreeSet();\r\n//Set indices to iterate two lists. I use i, j\r\nint i = 0;\r\nint j = 0;\r\nwhile(i!=PostingList_a.size() && j!=PostingList_b.size()){\r\n…\r\nThen we can use the result of intersection to perform a AND query as follows:\r\nSet <Integer> evaluateANDQuery(String a, String b){\r\nreturn intersection(invIndex.get(a), invIndex.get(b));\r\n}\r\n```\r\n\r\n### Evaluating/checking posting lists in the inverted index\r\nLet us get a feel of the corpus by exploring some examples. Assuming you have implemented the inverted index correctly.\r\nNumbering document indices starting at 1 (in our corpus), the posting lists for the following words should be as follows:\r\n\r\n```\r\nfreeze -> [129, 313, 442, 493, 912] (i.e., the term “freeze” is present in documents\r\n129, 313, etc.)\r\nctrl -> [23, 47, 138, 232, 498, 882, 993, 1106, 1124, 1218]\r\nwifi -> [46, 66, 113, 158, 746, 1248]\r\ncpu -> [604, 800, 959, 1156]\r\n```\r\n\r\n###Evaluating/checking AND queries\r\nAssuming you have implemented the intersection method correctly, then we should expect the following results for the following queries:\r\n```\r\nmouse AND wifi -> [113, 158] (i.e., there are two documents in our corpus which contain\r\nboth the terms “mouse” and “wifi”. And these are document at line 113 and 158 in all.txt)\r\nmouse AND scrolling -> [80, 86, 348, 1029]\r\nerrors AND report -> [] (i.e., there are no documents in the collection containing both\r\nthe terms “errors” and “report”)\r\n```\r\n\r\n###Implementing UNION and NOT operations on posting lists\r\n Implement the method Set<Integer> union(Set<Integer> a, Set<Integer> b) to evaluate and retrieve\r\ndocuments using the OR Boolean query. Union operation on queries mouse OR keyboard like simply means that we should\r\nretrieve all documents that appear either in the posting list of the term “mouse” or “keyboard”.\r\nYou can use the evaluateORQuery() method implemented to return the result of an OR query containing two terms.\r\nSet <Integer> evaluateORQuery(String a, String b){\r\nreturn union(invIndex.get(a), invIndex.get(b));\r\n}\r\nAssuming you have implemented union correctly, we should expect to get the following results for these queries:\r\n```\r\nyoutube OR reported -> [19, 67, 122, 227, 313, 342, 377, 507, 659, 825, 846]\r\nerrors OR report -> [115, 251, 471, 508, 674, 784, 821, 1068, 1080, 1111, 1158, 1245]\r\nhell OR movie -> [3, 89, 147, 192, 235, 262, 336, 342, 558, 766, 864, 882, 1120, 1244]\r\n```\r\n###Final Output\r\n```\r\n$> project_executable query_type query_string output_file_path\r\n```\r\nwhere query_type takes on one of the 4 values: PLIST, AND, OR, AND-NOT. Query_string takes the actual query and\r\noutput_file_path is the filename with path in ./ that should report the result of your query.\r\n\r\n```\r\nExample runs:\r\n$> project_executable PLIST cpu cpu_plist.txt\r\nShould produce\r\ncpu -> [604, 800, 959, 1156]\r\nas the contents of cpu_plist.txt\r\n$> project_executable AND mouse AND scrolling and_result.txt\r\nShould produce\r\nmouse AND scrolling -> [80, 86, 348, 1029]\r\nas the contents of and_result.txt\r\n$> project_executable AND-NOT Lenovo AND (NOT logitech) and_not_result.txt\r\nShould produce\r\nlenovo AND (NOT logitech) -> [360, 373, 379, 451, 517, 540, 787, 869, 942, 1055, 1146]\r\nas the contents of and_not_result.txt\r\n```\r\n\r\n### Authors and Contributors\r\nThis is my @KrithivasanChandran GitHub profile. \r\n\r\n### Support or Contact\r\nHaving trouble with running the project please contact me on : krithivasanchandran@gmail.com","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}